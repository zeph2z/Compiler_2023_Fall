Starting parse
Entering state 0
Reading a token: Next token is token INT ()
Shifting token INT ()
Entering state 1
Reducing stack by rule 3 (line 71):
   $1 = token INT ()
-> $$ = nterm FuncType ()
Stack now 0
Entering state 4
Reading a token: Next token is token IDENT ()
Shifting token IDENT ()
Entering state 6
Reading a token: Next token is token '(' ()
Shifting token '(' ()
Entering state 7
Reading a token: Next token is token ')' ()
Shifting token ')' ()
Entering state 8
Reading a token: Next token is token '{' ()
Shifting token '{' ()
Entering state 9
Reading a token: Next token is token RETURN ()
Shifting token RETURN ()
Entering state 11
Reading a token: Next token is token PLUS ()
Shifting token PLUS ()
Entering state 18
Reducing stack by rule 37 (line 337):
   $1 = token PLUS ()
-> $$ = nterm UnaryOp ()
Stack now 0 4 6 7 8 9 11
Entering state 34
Reading a token: Next token is token '(' ()
Shifting token '(' ()
Entering state 22
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 19
Reducing stack by rule 38 (line 337):
   $1 = token MINUS ()
-> $$ = nterm UnaryOp ()
Stack now 0 4 6 7 8 9 11 34 22
Entering state 34
Reading a token: Next token is token MINUS ()
Shifting token MINUS ()
Entering state 19
Reducing stack by rule 38 (line 337):
   $1 = token MINUS ()
-> $$ = nterm UnaryOp ()
Stack now 0 4 6 7 8 9 11 34 22 34
Entering state 34
Reading a token: Next token is token NOT ()
Shifting token NOT ()
Entering state 20
Reducing stack by rule 39 (line 337):
   $1 = token NOT ()
-> $$ = nterm UnaryOp ()
Stack now 0 4 6 7 8 9 11 34 22 34 34
Entering state 34
Reading a token: Next token is token INT_CONST ()
Shifting token INT_CONST ()
Entering state 17
Reducing stack by rule 36 (line 331):
   $1 = token INT_CONST ()
-> $$ = nterm Number ()
Stack now 0 4 6 7 8 9 11 34 22 34 34 34
Entering state 33
Reducing stack by rule 9 (line 117):
   $1 = nterm Number ()
-> $$ = nterm PrimaryExp ()
Stack now 0 4 6 7 8 9 11 34 22 34 34 34
Entering state 24
Reducing stack by rule 10 (line 126):
   $1 = nterm PrimaryExp ()
-> $$ = nterm UnaryExp ()
Stack now 0 4 6 7 8 9 11 34 22 34 34 34
Entering state 59
Reducing stack by rule 11 (line 132):
   $1 = nterm UnaryOp ()
   $2 = nterm UnaryExp ()
-> $$ = nterm UnaryExp ()
Stack now 0 4 6 7 8 9 11 34 22 34 34
Entering state 59
Reducing stack by rule 11 (line 132):
   $1 = nterm UnaryOp ()
   $2 = nterm UnaryExp ()
-> $$ = nterm UnaryExp ()
Stack now 0 4 6 7 8 9 11 34 22 34
Entering state 59
Reducing stack by rule 11 (line 132):
   $1 = nterm UnaryOp ()
   $2 = nterm UnaryExp ()
-> $$ = nterm UnaryExp ()
Stack now 0 4 6 7 8 9 11 34 22
Entering state 25
Reducing stack by rule 12 (line 142):
   $1 = nterm UnaryExp ()
-> $$ = nterm MulExp ()
Stack now 0 4 6 7 8 9 11 34 22
Entering state 26
Reading a token: Next token is token ')' ()
Reducing stack by rule 14 (line 159):
   $1 = nterm MulExp ()
-> $$ = nterm AddExp ()
Stack now 0 4 6 7 8 9 11 34 22
Entering state 27
Next token is token ')' ()
Reducing stack by rule 16 (line 176):
   $1 = nterm AddExp ()
-> $$ = nterm RelExp ()
Stack now 0 4 6 7 8 9 11 34 22
Entering state 28
Next token is token ')' ()
Reducing stack by rule 18 (line 193):
   $1 = nterm RelExp ()
-> $$ = nterm EqExp ()
Stack now 0 4 6 7 8 9 11 34 22
Entering state 29
Next token is token ')' ()
Reducing stack by rule 20 (line 210):
   $1 = nterm EqExp ()
-> $$ = nterm LAndExp ()
Stack now 0 4 6 7 8 9 11 34 22
Entering state 30
Next token is token ')' ()
Reducing stack by rule 22 (line 226):
   $1 = nterm LAndExp ()
-> $$ = nterm LOrExp ()
Stack now 0 4 6 7 8 9 11 34 22
Entering state 31
Next token is token ')' ()
Reducing stack by rule 6 (line 97):
   $1 = nterm LOrExp ()
-> $$ = nterm Exp ()
Stack now 0 4 6 7 8 9 11 34 22
Entering state 40
Next token is token ')' ()
Shifting token ')' ()
Entering state 62
Reducing stack by rule 7 (line 105):
   $1 = token '(' ()
   $2 = nterm Exp ()
   $3 = token ')' ()
-> $$ = nterm PrimaryExp ()
Stack now 0 4 6 7 8 9 11 34
Entering state 24
Reducing stack by rule 10 (line 126):
   $1 = nterm PrimaryExp ()
-> $$ = nterm UnaryExp ()
Stack now 0 4 6 7 8 9 11 34
Entering state 59
Reducing stack by rule 11 (line 132):
   $1 = nterm UnaryOp ()
   $2 = nterm UnaryExp ()
-> $$ = nterm UnaryExp ()
Stack now 0 4 6 7 8 9 11
Entering state 25
Reducing stack by rule 12 (line 142):
   $1 = nterm UnaryExp ()
-> $$ = nterm MulExp ()
Stack now 0 4 6 7 8 9 11
Entering state 26
Reading a token: Next token is token ';' ()
Reducing stack by rule 14 (line 159):
   $1 = nterm MulExp ()
-> $$ = nterm AddExp ()
Stack now 0 4 6 7 8 9 11
Entering state 27
Next token is token ';' ()
Reducing stack by rule 16 (line 176):
   $1 = nterm AddExp ()
-> $$ = nterm RelExp ()
Stack now 0 4 6 7 8 9 11
Entering state 28
Next token is token ';' ()
Reducing stack by rule 18 (line 193):
   $1 = nterm RelExp ()
-> $$ = nterm EqExp ()
Stack now 0 4 6 7 8 9 11
Entering state 29
Next token is token ';' ()
Reducing stack by rule 20 (line 210):
   $1 = nterm EqExp ()
-> $$ = nterm LAndExp ()
Stack now 0 4 6 7 8 9 11
Entering state 30
Next token is token ';' ()
Reducing stack by rule 22 (line 226):
   $1 = nterm LAndExp ()
-> $$ = nterm LOrExp ()
Stack now 0 4 6 7 8 9 11
Entering state 31
Next token is token ';' ()
Reducing stack by rule 6 (line 97):
   $1 = nterm LOrExp ()
-> $$ = nterm Exp ()
Stack now 0 4 6 7 8 9 11
Entering state 23
Next token is token ';' ()
Shifting token ';' ()
Entering state 41
Reducing stack by rule 5 (line 87):
   $1 = token RETURN ()
   $2 = nterm Exp ()
   $3 = token ';' ()
-> $$ = nterm Stmt ()
Stack now 0 4 6 7 8 9
Entering state 13
Reading a token: Next token is token '}' ()
Reducing stack by rule 31 (line 297):
   $1 = nterm Stmt ()
-> $$ = nterm BlockItem ()
Stack now 0 4 6 7 8 9
Entering state 16
Next token is token '}' ()
Shifting token '}' ()
Entering state 39
Reducing stack by rule 4 (line 79):
   $1 = token '{' ()
   $2 = nterm BlockItem ()
   $3 = token '}' ()
-> $$ = nterm Block ()
Stack now 0 4 6 7 8
Entering state 10
Reducing stack by rule 2 (line 61):
   $1 = nterm FuncType ()
   $2 = token IDENT ()
   $3 = token '(' ()
   $4 = token ')' ()
   $5 = nterm Block ()
-> $$ = nterm FuncDef ()
Stack now 0
Entering state 3
Reducing stack by rule 1 (line 53):
   $1 = nterm FuncDef ()
-> $$ = nterm CompUnit ()
Stack now 0
Entering state 2
Reading a token: Now at end of input.
Shifting token $end ()
Entering state 5
Stack now 0 2 5
Cleanup: popping token $end ()
Cleanup: popping nterm CompUnit ()